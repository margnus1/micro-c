\documentclass[a4paper,11pt]{article}

%% We can use macros to avoid typing the same thing over and over
\newcommand{\token}[1]{\texttt{<#1>}}
\newcommand{\uC}{{$\mathrm{\mu}$}C }
 \usepackage{tikz}
 \usepackage{tikz-qtree}
 \usepackage{array}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{listings}
\usepackage{alltt}
\usepackage[lighttt]{lmodern}

\title{Assignment 3: Semantic Analysis \\
       Compiler Design Project, 1DL420}
\author{Xiao Yang \and Magnus L{\aa}ng} % replace by your name(s)
\date{\today}
\begin{document}
\maketitle

We implement the semantic checker as a traversal of the AST generated by the parser.
We recursively check that each node of the AST is semantically valid in its context.

We use two different classes to represent all the types we consider in the semantic checking phase.

\section{Type Information}
\emph{Type} is class representing a \uC variable or expression type.
It is abstract in the sense that it's internal representation is abstracted from the rest of the semantic checker, thus, we implement type checking in terms of the public interface of \emph{Type}.
Nevertheless, we will describe both its internal representation and a selection of its public methods.

\subsection{Type Representation}
In the \emph{Type} class, the following information is included:
\begin{lstlisting}[language=Java,morekeywords={enum}]
public class Type {
    private enum Primitive
    { VOID, INT, CHAR, LITERAL, ARRAY }
    private Primitive type;
    private Type of;
    private Integer size;
    private SimpleNode expr;
}
\end{lstlisting}
\begin{description}

\item[type] is the primary field of a \emph{Type}. Only when $\texttt{type}
  = \emph{ARRAY}$ are the other fields used for type information.

  The \emph{LITERAL} value is an artifact from when we disallowed implicit
  \texttt{int} to \texttt{char} conversions. This has been changed, and
  \emph{LITERAL} is now semantically equivalent to \emph{INT}.

\item[of] is the type of the elements when $\texttt{type} = \emph{ARRAY}$.
  Here, only \emph{INT} and \emph{CHAR} are valid element types for arrays.

\item[size] is the number of elements in an array, but is optional.

  An array with a size is considered a different type than an array without
  a size (as is arrays of different sizes). To avoid confusion, we call
  arrays with a size \emph{Vectors} and arrays without a size
  \emph{Pointers}.

\item[SimpleNode expr] The field stores the AST node which generated the
  \emph{Type}, for use in error messages.

\end{description}

\subsection{Type Interface}
The public interface is used in the implementation of \emph{Symbol~Table} and \emph{Type~Checking}. Here, we describe some of the important methods.

\subsubsection*{assertConvertibleTo(Type, Expr)}
\label{sec:assertConvertibleTo}
This method enforces the rules of implicit type conversion, for example:
\begin{itemize}
\item \emph{int} and \emph{char} are interconvertible.
\item \emph{Vector} can be converted to \emph{Pointer} if the elements inside have the same type, but not the other way around.
\end{itemize}
When a conversion is disallowed, the method creates a semantic error.

\subsubsection*{unify(Type, Expr)}
This method constructs the result \emph{Type} of some arithmetic binary
operation between \textbf{this} and \textbf{Type}.

\subsubsection*{assertArithmetic(Expr)}
This method causes a semantic error if the type \textbf{this} can't be used in
arithmetic.


\subsection{Function Representation}
The types of functions are represented by the \emph{FunctionType} class.  A
\emph{FunctionType} can be created either from a \emph{Function Declaration} or
a \emph{Function Definition}. The following fields are part of
\emph{FunctionType}:

\begin{lstlisting}[language=Java]
public class FunctionType {
    private Type returnType;
    private Type[] argumentTypes;
    private SimpleNode node;
    private SimpleNode definition;
}
\end{lstlisting}

\begin{description}
\item[returnType] The return type of the function.
\item[argumentTypes] The types of the arguments. Implies the arity of the
  function.
\item[node] The AST \emph{Function Declaration} or \emph{Function Definition} node which generated the \emph{Function Type}.
\item[definition] The \emph{Function Definition} AST node that defines the function, if any.
  This field is initialized to \texttt{null} and and is used by \emph{Symbol Table} to keep track of where a function is defined.
\end{description}

\section{Environments}
An identifier refers to either a variable or a function in the \uC language. The
information about what each identifier map to at some particular point in the
program is stored in the \emph{Symbol Table}. In our design, we associate each
variable with a \emph{Type} instance and each function with a
\emph{FunctionType} instance.

\subsection{Implementation of Symbol Table and Scope Checking}
In general, we have have two data structures in our symbol table.
\begin{itemize}
\item \textbf{VarTable}: A Stack of HashMaps with \emph{Variable Name} as key
  and corresponding \emph{Type} as value.
\item \textbf{FuncTable}: A HashMaps with \emph{Function Name} as key and
  corresponding \emph{Function Type} as value.
\end{itemize}

Note that we have a Stack of HashMaps for variables while only one HashMap for
functions because functions can only be defined in global scope, while there
could be nested scopes for variable definitions.

The \emph{Symbol Table} supports the following operations:
\begin{itemize}
	\item \textbf{Enter Scope}\\
	Push one more HashMap onto the Stack.

	\item \textbf{Exit Scope} \\
	Pop up one HashMap from the Stack.

	\item \textbf{Add Variable} \\
	Retrieve the top HashMap of the Stack (i.e., the current scope) and add an entry for the variable to the HashMap. If a variable with the same name already exists, a semantic error is reported.

	\item \textbf{Add Function}
	\begin{itemize}
		\item \textbf{Add Function Declaration}
			When we see a \emph{Function Declaration} or \emph{Function Definition} in the AST, we use the node information to generate a \emph{FunctionType} instance with \texttt{null} \emph{Definition} field and then add it to the \emph{FuncTable}.
		\item \textbf{Add Function Definition}
			First, we search the \emph{FuncTable} to find a \emph{Function Type} with given name.
		\item Note that when we encounter a \emph{Function Definition},
          \textbf{Add Function Declaration} is invoked first and then
          \textbf{Add Function Definition}. So for all functions, it must be
          declared first and then be defined. In this way, it is easy for detect
          invocations of undeclared functions as well as function
          redeclarations.
	\end{itemize}

	\item \textbf{Find Variable} \\
	We search the \emph{VarTable} in a top-down direction to find the most recently defined variable with the given name. If the variable is found, we return the corresponding \emph{Type}. Otherwise, a semantic error is reported.

	\item \textbf{Find Function} \\
	In order to find a function in the \emph{Symbol Table}, we check both \emph{FuncTable} and all the HashMaps of \emph{VarTable}.
	\begin{itemize}
		\item If the given name can be found in the \emph{FuncTable} and cannot be find in any scope of \emph{VarTable}, we return the found \emph{FunctionType}.
		\item If the given name can be found in both \emph{FuncTable} and some scope of \emph{VarTable}, a ``Function is shadowed by local variable'' error is reported.
		\item If the given name cannot be found in \emph{FuncTable}, a ``Function undefined'' error is reported.
	\end{itemize}

\end{itemize}


\section{Type Checking}
\subsection{Type Conversion}
Type conversion rules and checking are implemented in the \emph{assertConvertibleTo} (Section~\ref{sec:assertConvertibleTo}) method in \emph{Type}.

\subsection{Assignment}
For assignment, we should consider whether the RHS can be assigned to the LHS. It requires either both LHS and RHS have the same type or RHS can be converted to LHS.

Since \emph{Assignment} is right-associative, each time we evaluate an assignment, the LHS is always an identifier and its type information can be retrieved from \emph{Symbol Table}, while the type information of RHS is generated from the evaluation of an \emph{Expression}.

\subsection{Binary Expression}
For \emph{Binary Expression}, we check both LHS and RHS are arithmetic and then we return the unified \emph{Type} according to the type information from LHS and RHS.

\subsection{Statement}
For \emph{If Statement} and \emph{While Statement}, we require the \emph{condition} to have an arithmetic type.

\subsection{Function Return Type}
We check whether the actual \emph{return type} is consistent with the one in the definition.

Also, if a function is declared return \texttt{void}, it cannot return a value. If declared non-void, it must return a value.

\subsection{Function Call}
For \emph{Function Call}, we first retrieve the \emph{Function Type} from the \emph{Symbol Table} with the function name. If the function name cannot be found in \emph{Symbol Table}, an semantic error will be generated. Then we check the number and type of arguments are matched between \emph{Function Call} and \emph{Function Definition}.

\subsection{ArrayLookup}
In array lookup nodes we check that the variable actually is an array, and that
the index expression has an arithmetic type.

\section{Error Messages}
Each semantic error is associated with a brief error message, an error position,
and any number of context information positions.

Below is a sample of the error messages generated for the provided testcases.

\begin{alltt}
# java Main incorrect/semantic/se14.c
\textbf{se14.c:12:3: \textcolor{red}{error:} Function f is shadowed by a local variable.}
  f(n);         // 'f' refers only to the local variable
\textbf{\color{green}  ^}
\textbf{se14.c:9:3:}
  int f;
\textbf{\color{green}  ^~~~~}
\end{alltt}

\begin{alltt}
# java Main incorrect/semantic/se20.c
\textbf{se20.c:7:3: \textcolor{red}{error:} You cannot assign to a vector.}
  a=b;
\textbf{\color{green}  ^~~}
\textbf{se20.c:5:3:}
  int a[10];
\textbf{\color{green}  ^~~~~~~~~}
\end{alltt}

\begin{alltt}
# java Main incorrect/semantic/se21.c
\textbf{se21.c:5:12: \textcolor{red}{error:} char[10] can't be converted to int.}
    return bv;  //  Return from function with erroneous type
\textbf{\color{green}           ^~~}
\textbf{se21.c:4:3:}
  char bv[10];
\textbf{\color{green}  ^~~~~~~~~~~}
\textbf{se21.c:3:1:}
int a(int n) \symbol{123}
\textbf{\color{green}^~~}
\end{alltt}

\end{document}
