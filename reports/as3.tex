\documentclass[a4paper,11pt]{article}

%% We can use macros to avoid typing the same thing over and over
\newcommand{\token}[1]{\texttt{<#1>}}
\newcommand{\uC}{{$\mathrm{\mu}$}C }
 \usepackage{tikz}
 \usepackage{tikz-qtree}
 \usepackage{array}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{listings}


\title{Assignment 3: Semantic Analysis \\
       Compiler Design Project, 1DL420}
\author{Xiao Yang \and Magnus L{\aa}ng} % replace by your name(s)
\date{\today}
\begin{document}
\maketitle

\section{Technical Issues}
We implement the semantic checker based on the AST generated before.
We check each node of the AST with corresponding rules during the traversal.

\subsection{Type Representation}
We use two different classes to wrap all the type to be considered in semantic checking phase. 
\subsubsection{Type}
\emph{Type} represents all primitive type information in our compiler. 
Thus, we can implement type checking based on information encapsulated in \emph{Type}.
In the \emph{Type} class, the following information is included:
\begin{itemize}
	
	\item \textbf{ Primitive Type} \\
	VOID \\
	INT \\
	CHAR	 \\
	LITERAL \\
	ARRAY 
	
	\item \textbf{Type of the Array} \\
	For array type, element type in the array should also be specified. 
	Here, only \emph{INT} and \emph{CHAR} are valid types for arrays. 
	
	\item \textbf{Size of the Array} \\
	While the size for an array is optional. (To avoid confusion, for array type with size, we call it a
	\emph{Vector} and for that without specified size, we call it a \emph{Pointer}.)
	
	\item \textbf{Node} \\
	The node stores the expression which generates the \emph{Type}.
	
\end{itemize}

Methods are also included in the class to ease the implementation of \emph{Symbol Table} and \emph{Type Checking}. Here, we just include some important ones in the report:
\begin{itemize}
	\item \textbf{canBeConvertedTo(Type)} \\
	Here, we enforce the rules:
	\begin{itemize}
		\item  \emph{char} can be converted to \emph{int}, but not the other way around.
		\item \emph{Pointer} can be assigned to \emph{Vector} if the elements inside have the same type, but not the other way around.
	\end{itemize}
	
	\item \textbf{unify(Type, Expr)} \\
	This method returns the \emph{Type} of an expression with the already known \emph{Type} from subexpression.
	
	\item \textbf{assertArithmetic(Expr)} \\
	This method judges the expression is arithmetic.
\end{itemize}



\subsubsection{Function Type}
	\emph{Function Type} will be generated when either a \emph{Function Declaration} or \emph{Function Definition} is encountered. The following information is included in the \emph{Function Type}:
	\begin{itemize}
	\item \textbf{Return Type} \\
		An instance of \emph{Type}.
	\item \textbf{List of Argument Types} \\
		A list of instances of \emph{Type}.
	\item \textbf{Node} \\
		A \emph{Function Declaration} or \emph{Function Definition} which generates the \emph{Function Type}
	\item \textbf{Definition} \\
		The corresponding \emph{Function Definition} node of the \emph{Function Type}. (This field is initialized to be \emph{null} and collaborates with \emph{Symbol Table}.)	
	\end{itemize}	
	 
\subsection{Identifier}
Identifier is either an variable or function in the \uC language. All the information about identifiers is stored in the \emph{Symbol Table}. In our design, we generate a \emph{Type} class instance for each variable and a \emph{Function Type} for each function as mentioned before.


\subsection{Implementation of Symbol Table and Scope Checking}

	In general, we have have two data structures in our symbol table. 
\begin{itemize}
	\item \textbf{VarTable}: A Stack of HashMaps with \emph{Variable Name} as key and corresponding \emph{Type} as value.
	\item \textbf{FuncTable}: A HashMaps with \emph{Function Name} as key and corresponding \emph{Function Type} as value.
\end{itemize}
	
	Note that we have a Stack of HashMaps for variables while only one HashMap for functions. Because functions can only be defined in global scope, while there could be nested scopes for variable definitions. \\
	
	The \emph{Symbol Table} supports the following operations:
\begin{itemize}
	\item \textbf{Enter Scope}\\
	Push one more HashMap onto the Stack.
	
	\item \textbf{Exit Scope} \\
	Pop up one HashMap from the Stack.
	
	\item \textbf{Add Variable} \\
	Retrieve the top HashMap of the Stack (i.e., the current scope of variables) and add an entry for the variable to the HashMap. If a variable with the same name already existed, an error of\emph{Variable Redeclaration} is reported.
	
	\item \textbf{Add Function} 
	\begin{itemize}
		\item \textbf{Add Function Declaration}
			When we see a \emph{Function Declaration} or \emph{Function Definition} in the AST, we use the node information to generation a \emph{Function Type} instance with null \emph{Definition} field and then add it to the \emph{FuncTable}.
		\item \textbf{Add Function Definition}
			First, we search the \emph{FuncTable} to find a \emph{Function Type} with given name. 
		\item Note that when we encounter a \emph{Function Definition}, \textbf{Add Function Declaration} is invoked first and then \textbf{Add Function Definition}. So for all functions, it must be declared first and then be defined. In this way, it is easy for detect the errors of \textit{Invocation of Undeclared Function} or \textit{Function Redeclaration}.
	\end{itemize}
	
	\item \textbf{Find Variable} \\
	We search the \emph{VarTable} in a top-down way to find the most recently defined variable with the given name. If the variable is found, we return the corresponding \emph{Type}. Otherwise, an error of \textit{Undefined Variable} is reported.
	
	\item \textbf{Find Function} \\
	In order to find a function in the \emph{Symbol Table}, we check both \emph{FuncTable} and the top HashMap of \emph{VarTable} (the current variable scope). 
	\begin{itemize}
		\item If the given name can be found in the \emph{FuncTable} and cannot be find in the current scope in the \emph{VarTable}, we return the found \emph{Function Type}.
		\item If the given name can be found in both \emph{FuncTable} and the current scope of \emph{VarTable}, an error of \textit{Function is shadowed by local variable} is reported.
		\item If the given name cannot be found in \emph{FuncTable}, an error of \textit{Function undefined} is reported.
	\end{itemize}
	
	
\end{itemize}


\subsection{Type Checking}
\begin{itemize}
	
	
	\item \textbf{Type Conversion} \\
	We only allow a \textit{char} to be converted to a \textit{int}.\\
	We use the \emph{canBeConvertedTo} method in the \emph{Type} to compare to implement it.
		
	\item \textbf{Assignment} \\
		For assignment, we should consider whether the RHS can be assigned to the LHS. It requires either both LHS and RHS have the same type or RHS can be converted to LHS. \\
		Since \emph{Assignment} is right-associative, each time we evaluate an assignment, the LHS is always an identifier and its type information can be retrieved from \emph{Symbol Table}, while the type information of RHS is generated from the evaluation of an \emph{Expression}.
			
	
	\item \textbf{Binary Expression} \\
	For \emph{Binary Expression}, we check both LHS and RHS are arithmetic and then we return the unified \emph{Type} according to the type information from LHS and RHS.
	
	\item \textbf{Statement} \\
	For \emph{If Statement} and \emph{While Statement}, we'll check whether the \emph{condition} is an arithmetic expression or not.
	
	
	\item \textbf{Function Return Type}\\
	We check whether the actual \emph{return type} is consistent with the one in the definition.\\
	Also, if a function is declared return \emph{void}, it cannot return a value. If declared non-void, it must return a value.
	
	\item \textbf{Function Call} \\
	For \emph{Function Call}, we first retrieve the \emph{Function Type} from the \emph{Symbol Table} with the function name. If the function name cannot be found in \emph{Symbol Table}, an semantic error will be generated. Then we check the number and type of arguments are matched between \emph{Function Call} and \emph{Function Definition}. 
\end{itemize}


\subsection{Other Semantic Error}
	In the previous sections, we mentioned about how we deal with the semantic error related to \emph{Type} and \emph{Scope}. 
	
	\begin{itemize}
	
	\item \textbf{ArrayLookup} \\
	For arrays with size specified, we'll check whether the index part is and arithmetic expression and whether the given index exceeds the size of an array. 
	
	\end{itemize}
	
\subsection{Error Message}
	For each semantic error, we give the error type and corresponding position information.
	
 %do you want to mention the highlight?

\end{document}
