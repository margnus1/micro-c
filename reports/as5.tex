\documentclass[a4paper,11pt]{article}

\title{Assignment 5: MIPS Assembly Code}
\author{Xiao Yang \and Magnus L{\aa}ng}
\date{\today}

\usepackage{multirow}
\usepackage{listings}
\usepackage{mips}

%% Simple syntax highlighting for our RTL. Add more keywords here.
\lstset{language=[mips]Assembler,
  morekeywords={Procedure, ADD, SUB, MUL, DIV, LTEQ, LT, EQ, NE, GTEQ, GT, Mov,
    Not, Neg, Jump, Branch, Zero, NonZero, IntConst, GlobalAddress, Store, Load,
    BYTE, INT, Call, ArrayAddress}}

\begin{document}
\maketitle

\section{Technique Issues}
\subsection{Control Flow Translation}
In the previous RTL code generation phase, we have already translate the \textbf{control flows} with \textit{Branch}, \textit{Jump} and \textit{Label}. So in the MIPS code generation phase, we simply translate the the corresponding RTL code into MIPS code.


\subsection{Calling Convention}
We use O32 calling convention in our implementation:
	\textbf{Calling Sequence:}
	\begin{enumerate}
		\item Caller allocates space on the stack for all arguments, stores the first four arguments in the argument registers (\$a0-\$a3) and the rest to stack frame.
		\item Caller transfer the control to callee and save the return address to \$ra.
		\item Callee allocates space on the stack frame.
		\item Callee pushes the first 4 arguments in \$a0-\$a3 (if any) onto the stack frame.
		\item Callee saves the return address (the value of \$ra) onto the stack frame.
		\item Callee saves the old frame pointer (\$fp).
		\item Callee set the new frame pointer (\$fp) with the current value of \$sp.
	\end{enumerate}

	\textbf{Return sequence:}
	\begin{enumerate}	
		\item Callee load the return address from stack to \$ra.
		\item Callee stores the return value in register \$v0.
		\item Callee adjust the \$fp with the stored old frame pointer value.
		\item Callee deallocates the space on the stack.
		\item Callee give control back to caller.
		\item Caller deallocates the space for arguments on the stack.
		\item Caller get the return value.

	\end{enumerate}

\begin{table}
\begin{tabular}{ |c| c}
... & low address \\ \hline

 $b_n$  & \multirow{6}{*}{space for arrays}\\ \cline{1-1}
... & \\ \cline{1-1}
$b_0$ & \\  \cline{1-1}
$a_m$ & \\  \cline{1-1}
... & \\  \cline{1-1}
$a_0$ & \\  \cline{1-2}


$t_n$ & \multirow{3}{*}{space for RTL temporaries} \\\cline{1-1}
... \\ \cline{1-1}
$t_0$ \\ \hline


 $\$fp$  & old \$fp \\ \hline
 $\$ra$  &  return address \\ \hline


$arg_n$ & \multirow{6}{*}{space for arguments} \\ \cline{1-1}
... \\ \cline{1-1}
$arg_4$ \\ \cline{1-1}
$arg_3$ \\ \cline{1-1} 
... \\ \cline{1-1}
$arg_0$ \\ \hline


 ... & high address \\
\end{tabular}
\caption{Stack Frame}
\label{tab:stack}
\end{table}

\subsection{Stack Frame}
The stack grows from high address to low address. And the layout is shown in Table \ref{tab:stack}.
\subsection{Mapping of Registers}
The following MIPS registers are used:
\begin{itemize}
	\item \textbf{\$a0 to \$a3}: the first four arguments in function calls.
	\item \textbf{\$sp}: the stack pointer
	\item \textbf{\$fp}: the frame pointer
	\item \textbf{\$ra}: the return address
	\item All other RTL temporary registers used in the previous RTL code generation phase are mapped onto the stack frame as temporaries.
\end{itemize}

\newpage
\appendix

\section{Sample Code for Function Call}
\subsection{Prologue of Function Call}
\textbf{Caller:}
\begin{lstlisting}
    addiu   $sp, $sp, -4 # allocate space on the stack for argument(s).
    lw      $a0, 12($fp) # load the first argument to $a0
    jal     f            # call procedure f

\end{lstlisting}

\noindent \textbf{Callee:}
\begin{lstlisting}
    addiu   $sp, $sp, -44 # adjust the stack pointer
    sw      $ra, 40($sp)  # save the return address
    sw      $fp, 36($sp)  # save the old frame pointer
    move    $fp, $sp      # set new frame pointer
    sw      $a0, 44($fp)  # store the first argument onto the stack
\end{lstlisting}

\subsection{Epilogue of Function Call}
\textbf{Caller:}
\begin{lstlisting}
    addiu   $sp, $sp, 4 # deallocate space for argument(s) on the stack.
    sw      $v0, 0($fp) # get the return value (if any).
\end{lstlisting}

\noindent \textbf{Callee:}
\begin{lstlisting}
    lw      $ra, 40($fp) # load return address to $ra
    lw      $v0, 32($fp) # save return value to $v0
    lw      $fp, 36($sp) # load old frame pointer
    addiu   $sp, $sp, 44 # free the allocated space on stack
    jr      $ra          # return control to caller
\end{lstlisting}


\end{document}