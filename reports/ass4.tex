\documentclass[a4paper,11pt]{article}

%% We can use macros to avoid typing the same thing over and over
\newcommand{\token}[1]{\texttt{<#1>}}
\newcommand{\uC}{{$\mathrm{\mu}$}C }
 \usepackage{tikz}
 \usepackage{tikz-qtree}
 \usepackage{array}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{listings}
\usepackage{mips}
\usepackage{alltt}
\usepackage{hyperref}
\usepackage[lighttt]{lmodern}

%% Simple syntax highlighting for our RTL. Add more keywords here.
\lstset{keywords={Procedure, ADD, SUB, MUL, DIV, LTEQ, LT, EQ, NE, GTEQ, GT,
    Mov, Not, Neg, Jump, Branch, Zero, NonZero, IntConst, GlobalAddress, Store,
    Load, BYTE, INT, Call, ArrayAddress}}

\title{Assignment 4: ICode Generation \\
       Compiler Design Project, 1DL420}
\author{Xiao Yang \and Magnus L{\aa}ng}
\date{\today}
\begin{document}
\maketitle

\section{Technique Issues}
\subsection{Control Flows}
	We translate \textbf{While Statement}, \textbf{If Statement} and binary operator \textbf{\&\& } into \textit{control flows} in our RTL
	\begin{itemize}
	\item \textbf{While Statement} 
		\lstset{language=[mips]Assembler}
		\begin{lstlisting}
Jump while_cond
while_loop:
# instructions in the while loop
while_cond:
# instructions to evaluate the conditions
# and put the result into r
Branch while_loop, NonZero, r
		\end{lstlisting}
	
	\item \textbf{If Statement}
	\begin{lstlisting}
# instructions to evalution the conditions
# and put the result into r
Branch end_if, Zero, r
# instructions in the if statement
end_if:
	\end{lstlisting}
	
	\item \textbf{\&\& Operator}
	\begin{lstlisting}
# evaluate the LHS and put the result into r0
Branch andshortcircut, NonZero, r0
# evaluate the RHS 
    andshortcircut:
	\end{lstlisting}
	\end{itemize}
	
\subsection{Variables}
\begin{itemize}
	\item \textbf{Local Variable} \\
	We allocate a \textit{register} for a local variable declaration. \\
	During the translation, we maintain a list of registers allocated for certain procedure. So when a reference to a local variable in the source code is encountered , the corresponding allocated register is used in RTL.
	
	\item \textbf{Global Variable} \\
	We generate a \textit{label} for a global variable declaration. \\
	We use the RTL instruction \textit{GlobalAddress} to fetch the address of a global variable.
	
	\item \textbf{Local Array} \\
	When a local array is declared, we allocate slots on the frame to store it. Thus, the frame size in RTL is the total length of the local arrays.\\
	Each time an array reference is encountered, we use \textit{ArrayAddress} to fetch the base address of the array. After adding the base address by specified offset, we can access elements in the array.
	
	\item \textbf{Global Array} \\
	The same as global variables, when an declaration of global array is encountered, we generate a label for it.\\
	For reference resolution, the only difference is we use \textit{GlobalAddress} RTL instruction to fetch the base address of a global array. 
	\end{itemize}
	
\subsection{Expressions}
	An expression is flattened by generating corresponding instructions for AST subtree nodes in the bottom-up way. The intermediate result of a sub-expression is stored in temporary RTL registers and be operated on in the following expressions.\\
	For example, $m=x+y*3-z$ will have the following RTL code:
	\begin{lstlisting}
      r8 <- IntConst 3
      r7 <- MUL r3, r8
      r6 <- ADD r2, r7
      r5 <- SUB r6, r4
      r1 <- Mov r5
      r9 <- IntConst 3
	\end{lstlisting}
	
\subsection{Procedure}
For a procedure, we will generate the following code. We allocate temporaries for \textit{return value}, \textit{formals}, \textit{locals} and registers used for intermediate results.While space for local arrays is allocated on stack.
\begin{lstlisting}
Procedure procedure_name
    Argument count: #args
    Stack frame size: total_array_size
    Register types:
      RV: register_type
      R1: register_type
      ...
      
      Rn: register_type
    Instructions:
      ...
      exit_label
    
\end{lstlisting}

\section{RTL Design Rationale}
\begin{itemize}
  \item Why flat datatypes?
  \item Why no distinction between locals and temporaries?
  \item Why having regs $1,\, \dots,\, n$ be the $n$ formals?
  \item Why \texttt{\textbf{ArrayAddress}} instead of \textbf{FP}? \\
  We don't know where local arrays will be put on the stack in later implementation. So we RTL instruction \textbf{ArrayAddress} instead of calculating offset based on \textbf{FP} to fetch the base address of a local array. 
\end{itemize}

\newpage
\appendix
\renewcommand\thesection{Appendix \Alph{section}} %% Add the word ``Appendix'' to the numbering

\section{RTL Documentation}
This documentation is also distributed with the source code, in the
\path{doc/RTL.md} file.
%% TODO: convert (preferably automatically) our RTL doc to LaTeX and paste it
%% here with \include or \input or \subfile

\section{Sample RTL for Test Files}
\subsection{\texttt{quiet/lexer/l05.c}}
\begin{lstlisting}
Procedure main
  Argument count: 0
  Stack frame size: 0
  Register types:
    RV: INT
    r1: INT
    r2: INT
    r3: INT
    r4: INT
    r5: INT
    r6: INT
    r7: INT
    r8: INT
    r9: INT
    r10: INT
    r11: INT
    r12: INT
    r13: INT
    r14: INT
    r15: INT
    r16: INT
    r17: INT
    r18: INT
    r19: INT
    r20: INT
    r21: INT
    r22: INT
    r23: INT
    r24: INT
    r25: INT
    r26: INT
    r27: INT
    r28: INT
    r29: INT
    r30: INT
    r31: INT
    r32: INT
  Instructions:
      r3 <- IntConst 1
      r4 <- IntConst 3
      r4 <- Not r4
      r2 <- NE r3, r4
      r6 <- IntConst 4
      r5 <- Mov r6
      Branch main.andshortcircut, NonZero, r5
      r7 <- IntConst 6
      r5 <- Mov r7
    main.andshortcircut:
      r10 <- IntConst 7
      r11 <- IntConst 8
      r9 <- MUL r10, r11
      r12 <- IntConst 10
      r8 <- ADD r9, r12
      r15 <- IntConst 11
      r16 <- IntConst 12
      r14 <- SUB r15, r16
      r18 <- IntConst 12
      r19 <- IntConst 16
      r17 <- DIV r18, r19
      r13 <- ADD r14, r17
      r22 <- IntConst 17
      r23 <- IntConst 18
      r21 <- LTEQ r22, r23
      r24 <- IntConst 20
      r24 <- Neg r24
      r20 <- LT r21, r24
      r26 <- IntConst 21
      r27 <- IntConst 22
      r25 <- EQ r26, r27
      r1 <- Mov r25
      r30 <- IntConst 25
      r31 <- IntConst 27
      r29 <- GTEQ r30, r31
      r32 <- IntConst 28
      r28 <- GT r29, r32
    main.exit:
\end{lstlisting}

\subsection{\texttt{quiet/rtl/r01.c}}
\begin{lstlisting}
y: 1
x: 4
Procedure main
  Argument count: 0
  Stack frame size: 0
  Register types:
    RV: INT
    r1: INT
    r2: BYTE
    r3: INT
    r4: INT
    r5: INT
    r6: INT
    r7: INT
    r8: INT
  Instructions:
      r3 <- IntConst 42
      r4 <- GlobalAddress x
      r4 <- Store INT r3
      r5 <- IntConst 43
      r6 <- GlobalAddress y
      r6 <- Store BYTE r5
      r7 <- IntConst 65
      r1 <- Mov r7
      r8 <- IntConst 10
      r2 <- Mov r8
    main.exit:
\end{lstlisting}

\subsection{\texttt{quiet/rtl/r02.c}}
\begin{lstlisting}
Procedure f
  Argument count: 2
  Stack frame size: 0
  Register types:
    RV: INT
    r1: INT
    r2: INT
    r3: INT
  Instructions:
      r3 <- ADD r1, r2
      RV <- Mov r3
      Jump f.exit
    f.exit:
Procedure main
  Argument count: 0
  Stack frame size: 0
  Register types:
    RV: INT
    r1: INT
    r2: INT
    r3: INT
  Instructions:
      r1 <- IntConst 2
      r2 <- IntConst 3
      r3 <- Call f r1, r2
    main.exit:
\end{lstlisting}

\subsection{\texttt{quiet/rtl/r03.c}}
\begin{lstlisting}
a: 40
Procedure main
  Argument count: 0
  Stack frame size: 12
  Register types:
    RV: INT
    r1: INT
    r2: INT
    r3: INT
    r4: INT
    r5: INT
    r6: INT
    r7: INT
    r8: INT
    r9: INT
    r10: INT
    r11: INT
    r12: INT
    r13: INT
    r14: INT
    r15: INT
    r16: INT
  Instructions:
      r2 <- GlobalAddress a
      r3 <- IntConst 5
      r4 <- IntConst 4
      r4 <- MUL r4, r3
      r4 <- ADD r4, r2
      r4 <- Load INT r4
      r5 <- IntConst 7
      r1 <- ADD r4, r5
      r6 <- GlobalAddress a
      r7 <- IntConst 3
      r8 <- IntConst 4
      r8 <- MUL r8, r7
      r8 <- ADD r8, r6
      r8 <- Store INT r1
      r10 <- ArrayAddress 0
      r11 <- IntConst 5
      r12 <- IntConst 1
      r12 <- MUL r12, r11
      r12 <- ADD r12, r10
      r12 <- Load BYTE r12
      r13 <- IntConst 7
      r9 <- ADD r12, r13
      r14 <- ArrayAddress 0
      r15 <- IntConst 3
      r16 <- IntConst 1
      r16 <- MUL r16, r15
      r16 <- ADD r16, r14
      r16 <- Store BYTE r9
    main.exit:
\end{lstlisting}

\subsection{\texttt{quiet/rtl/r04.c}}
\begin{lstlisting}
Procedure f
  Argument count: 1
  Stack frame size: 0
  Register types:
    RV: INT
    r1: INT
  Instructions:
    f.exit:
Procedure main
  Argument count: 0
  Stack frame size: 8
  Register types:
    RV: INT
    r1: INT
  Instructions:
      r1 <- ArrayAddress 0
      Call f r1
    main.exit:
\end{lstlisting}

\subsection{\texttt{quiet/rtl/r05.c}}
\begin{lstlisting}
a: 40
Procedure f
  Argument count: 1
  Stack frame size: 0
  Register types:
    RV: INT
    r1: INT
    r2: INT
    r3: INT
    r4: INT
    r5: INT
    r6: INT
    r7: INT
  Instructions:
      r3 <- IntConst 5
      r4 <- IntConst 4
      r4 <- MUL r4, r3
      r4 <- ADD r4, r1
      r4 <- Load INT r4
      r5 <- IntConst 7
      r2 <- ADD r4, r5
      r6 <- IntConst 3
      r7 <- IntConst 4
      r7 <- MUL r7, r6
      r7 <- ADD r7, r1
      r7 <- Store INT r2
    f.exit:
Procedure main
  Argument count: 0
  Stack frame size: 0
  Register types:
    RV: INT
    r1: INT
  Instructions:
      r1 <- GlobalAddress a
      Call f r1
    main.exit:
\end{lstlisting}

\end{document}
