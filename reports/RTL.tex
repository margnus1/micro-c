%% Autogenerated from doc/RTL.md with ``kramdown'' tool, do not manually edit.
\hypertarget{rtl}{}\label{rtl}

RTL operates on a register machine with an infinite amount of
registers. The registers are identified by integer numbers starting
with zero. Register zero is reserved for the return value of the
current procedure. Registers 1 through \emph{n} are the parameters to the
current \emph{n}-ary fuction.

All registers are associated with a type, described by the \emph{RtlType}
enumeration, having one of the following values.

\begin{verbatim}Int, Byte
\end{verbatim}

The size of an {\tt Int} is 4 bytes.

In addition to the registers, each procedure has a certain, specified
per procedure, number of bytes of stack space available for use. The
code aquires the address to this stack space using the {\tt ArrayAddress}
instruction.

\subsection{Instructions}\hypertarget{instructions}{}\label{instructions}

These are the available instructions in the RTL.

\subsubsection{Binary}\hypertarget{binary}{}\label{binary}

\begin{verbatim}Binary(Dest, BinOp, Lhs, Rhs)
\end{verbatim}

Computes a binary instruction that acts on two registers \emph{Lhs} and
\emph{Rhs}, and puts the result in a third register \emph{Dest}.

The \emph{BinOp} enumeration can have the following values.

\begin{verbatim}Add, Sub, Mul, Div, Gt, Lt, GtEq, LtEq, Eq, Ne
\end{verbatim}

The instruction is sometimes pretty-printed as

\begin{verbatim}Dest <- BinOp Lhs, Rhs
\end{verbatim}

\subsubsection{Unary}\hypertarget{unary}{}\label{unary}

Another instruction is {\tt Unary}:

\begin{verbatim}Unary(Dest, UnOp, Arg)
\end{verbatim}

Computes a unary operation that acts on a register \emph{Arg} and puts the
result in a register \emph{Dest}.

The \emph{UnOp} enumeration can have the following values.

\begin{verbatim}Not, Neg, Mov
\end{verbatim}

The instruction is sometimes pretty-printed as

\begin{verbatim}Dest <- UnOp Arg
\end{verbatim}

\subsubsection{Load}\hypertarget{load}{}\label{load}

The {\tt Load} instruction loads a value of type \emph{RtlType} from a memory
address stored in a register \emph{Addr} and writes the loaded value into
register \emph{Dest}.

\begin{verbatim}Load(Dest, RtlType, Addr)
\end{verbatim}

The instruction is sometimes pretty-printed as

\begin{verbatim}Dest <- Load RtlType Addr
\end{verbatim}

\subsubsection{Store}\hypertarget{store}{}\label{store}

The {\tt Store} instruction writes a value of type \emph{RtlType} stored in a
register \emph{Val} to a memory addres stored in register \emph{Addr}.

\begin{verbatim}Store(Addr, RtlType, Val)
\end{verbatim}

The instruction is sometimes pretty-printed as

\begin{verbatim}Addr <- Store RtlType Val
\end{verbatim}

\subsubsection{ArrayAddress}\hypertarget{arrayaddress}{}\label{arrayaddress}

The {\tt ArrayAddress} instruction computes a memory address that is
\emph{Offset} bytes after the memory location in the stack frame where
array locals are stored into a register \emph{Dest}. Note that \emph{Offset} is
an non-negative integer constant.

\begin{verbatim}ArrayAddress(Dest, Offset)
\end{verbatim}

The instruction is sometimes pretty-printed as

\begin{verbatim}Dest <- ArrayAddress Offset
\end{verbatim}

\subsubsection{GlobalAddress}\hypertarget{globaladdress}{}\label{globaladdress}

The {\tt GlobalAddress} instruction loads the memory address of a global
variable or constant with name \emph{Name} into a register \emph{Dest}.

\begin{verbatim}GlobalAddress(Dest, Name)
\end{verbatim}

The instruction is sometimes pretty-printed as

\begin{verbatim}Dest <- GlobalAddress Name
\end{verbatim}

\subsubsection{IntConst}\hypertarget{intconst}{}\label{intconst}

The {\tt IntConst} instruction loads an integer constant \emph{Const} into a
register \emph{Dest}.

\begin{verbatim}IntConst(Dest, Const)
\end{verbatim}

The instruction is sometimes pretty-printed as

\begin{verbatim}Dest <- IntConst Const
\end{verbatim}

\subsubsection{Label}\hypertarget{label}{}\label{label}

The {\tt Label} instruction has no side effects, but defines a location in
the program code that is identified by a string \emph{name}, and may be the
target of control flow instructions. The name must be unique in the
entire program, and may not clash with the names of functions or
global variables.

\begin{verbatim}Label(Name)
\end{verbatim}

The instruction is sometimes pretty-printed as

\begin{verbatim}Name:
\end{verbatim}

\subsubsection{Branch}\hypertarget{branch}{}\label{branch}

The {\tt Branch} instruction diverts control flow to after a {\tt Label}
instruction with name \emph{Name} in the same procedure based on the value
of the register \emph{Cond}.

\begin{verbatim}Branch(Name, Mode, Cond)
\end{verbatim}

The \emph{Mode} enumeration defines what values of the register \emph{Cond} that
causes the control flow to be diverted.

\begin{verbatim}Zero, NonZero
\end{verbatim}

The instruction is sometimes prettyprinted as

\begin{verbatim}Branch Name, Mode, Cond
\end{verbatim}

\subsubsection{Jump}\hypertarget{jump}{}\label{jump}

The {\tt Jump} instruction unconditinally transfers control flow to after a
{\tt Label} instructiom with name \emph{Name} in the same procedure.

\begin{verbatim}Jump(Name)
\end{verbatim}

The instruction is sometimes prettyprinted as

\begin{verbatim}Jump Name
\end{verbatim}

\subsubsection{Call}\hypertarget{call}{}\label{call}

The {\tt Call} instruction calls another procedure with the name \emph{Name},
sending the values of the registers \emph{Args} as arguments, placing the
return value in register \emph{Dest}.

\begin{verbatim}Call(Dest, Name, Args)
\end{verbatim}

The \emph{Dest} parameter may be -1, signifying that the return value (if
any) should be discarded. In this form, the instruction may be
constructed as

\begin{verbatim}Call(Name, Args)
\end{verbatim}

The instruction is sometimes prettyprinted as

\begin{verbatim}Dest <- Call Name [Arg [, Arg...]]

Call Name [Arg [, Arg...]]
\end{verbatim}
